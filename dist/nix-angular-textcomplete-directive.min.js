"use strict";!function(){angular.module("nix.textcomplete",["ngTextcomplete"]).factory("TextCompleteStrategy",["$q","$filter","$log",function(t,e,r){function n(){this.sources=[],this.minChars=1}return n.prototype.match=/(^|\s)([\w\-]*)$/,n.prototype.search=function(t,e){var r=[];(t&&t.toString()||"").length>=this.minChars&&this.sources.forEach(function(e){if(e.data.length){for(var n=[],o=0;o<e.data.length&&(-1===r.indexOf(e.data[o])&&e.data[o].toLowerCase().indexOf(t.toLowerCase())>-1&&n.push(e.data[o]),!(e.limit>0&&n.length>=e.limit));o+=1);r=r.concat(n)}}),this.minChars=2,e(r)},n.prototype.index=2,n.prototype.replace=function(t){return"$1"+t+" "},n.prototype.addSource=function(n,o,a){var i={data:[],priority:o||0,limit:a||-1};t.when(n).then(function(t){angular.isArray(t)?i.data=e("orderBy")(t,"length"):r.error("Source did not resolve to array:",n,t)}),this.sources.push(i),this.sources.sort(function(t,e){return e.priority-t.priority})},n}]).directive("textcomplete",["Textcomplete",function(t){return{restrict:"EA",scope:{strategy:"="},replace:!0,require:"ngModel",template:"<textarea></textarea>",link:function(e,r,n,o){var a=new t(r,angular.isArray(e.strategy)?e.strategy:[e.strategy]);angular.element(a).on({"textComplete:select":function(t,r){e.$apply(function(){o.$setViewValue(r)})},"textComplete:show":function(t){angular.element(this).data("autocompleting",!0)},"textComplete:hide":function(t){angular.element(this).data("autocompleting",!1)}})}}}])}();