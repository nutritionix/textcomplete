"use strict";!function(){angular.module("nix.textcomplete",["ngTextcomplete"]).factory("TextCompleteStrategy",["$q","$filter","$log",function(t,e,r){function n(){this.sources=[],this.minChars=1}return n.prototype.match=/(^|\s)([\w\-]*)$/,n.prototype.search=function(t,e){var r=[],n=[];(t&&t.toString()||"").length>=this.minChars&&this.sources.forEach(function(e){if(e.data.length){for(var o=[],a=0;a<e.data.length&&(-1===n.indexOf(e.data[a])&&e.data[a].toLowerCase().indexOf(t.toLowerCase())>-1&&o.push(e.data[a]),!(e.limit>0&&o.length>=e.limit));a+=1);n=n.concat(o),r=r.concat(o.map(function(t){return{text:t,source:e}}))}}),this.minChars=2,e(r)},n.prototype.index=2,n.prototype.replace=function(t){return"$1"+t+" "},n.prototype.addSource=function(n,o,a,i,u){var c={data:[],priority:o||0,limit:a||-1,template:angular.isFunction(u)||function(t){return t}};t.when(n).then(function(t){angular.isArray(t)?c.data=i?t:e("orderBy")(t,"length"):r.error("Source did not resolve to array:",n,t)}),this.sources.push(c),this.sources.sort(function(t,e){return e.priority-t.priority})},n.prototype.template=function(t){return t.source.template(t.text)},n}]).directive("textcomplete",["Textcomplete",function(t){return{restrict:"EA",scope:{strategy:"="},replace:!0,require:"ngModel",template:"<textarea></textarea>",link:function(e,r,n,o){var a=new t(r,angular.isArray(e.strategy)?e.strategy:[e.strategy]);angular.element(a).on({"textComplete:select":function(t,r){e.$apply(function(){o.$setViewValue(r)})},"textComplete:show":function(t){angular.element(this).data("autocompleting",!0)},"textComplete:hide":function(t){angular.element(this).data("autocompleting",!1)}})}}}])}();