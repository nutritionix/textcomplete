"use strict";!function(){angular.module("nix.textcomplete",["ngTextcomplete"]).factory("TextCompleteStrategy",["$q","$filter","$log",function(t,e,o){function r(){this.sources=[]}return r.prototype.match=/(^|\s)([\w\-]*)$/,r.prototype.search=function(t,e){var o=[];(t&&t.toString()||"").length>=3&&this.sources.forEach(function(e){if(e.data.length){for(var r=[],a=0;a<e.data.length&&(-1===o.indexOf(e.data[a])&&e.data[a].toLowerCase().indexOf(t.toLowerCase())>-1&&r.push(e.data[a]),!(e.limit>0&&r.length>=e.limit));a+=1);o=o.concat(r)}}),e(o)},r.prototype.index=2,r.prototype.replace=function(t){return"$1"+t+" "},r.prototype.addSource=function(r,a,n){var i={data:[],priority:a||0,limit:n||-1};t.when(r).then(function(t){angular.isArray(t)?i.data=e("orderBy")(t,"length"):o.error("Source did not resolve to array:",r,t)}),this.sources.push(i),this.sources.sort(function(t,e){return e.priority-t.priority})},r}]).directive("textcomplete",["Textcomplete",function(t){return{restrict:"EA",scope:{strategy:"=",message:"="},replace:!0,template:'<textarea ng-model="message" type="text"></textarea>',link:function(e,o){console.log(e.strategy);var r=new t(o,angular.isArray(e.strategy)?e.strategy:[e.strategy]);angular.element(r).on({"textComplete:select":function(t,o){e.$apply(function(){e.message=o})},"textComplete:show":function(t){angular.element(this).data("autocompleting",!0)},"textComplete:hide":function(t){angular.element(this).data("autocompleting",!1)}})}}}])}();